{
  "hash": "2d289d9ccdbb4e34f8f91040e1e45234",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 3.8: TMLE in the Clean-Room Framework for Pharmacoepidemiology\"\nformat: html\n---\n\n\n\n\n# Chapter 3.8: TMLE in the Clean-Room Framework\n*Pre-specified, reproducible causal inference for regulatory pharmacoepidemiology*\n\nIn many regulatory settings, analysts cannot freely explore the data. Post-marketing safety studies, multi-database pharmacoepidemiology collaborations, and distributed data network analyses often require a **clean-room workflow**: the analysis plan is pre-specified before data access, code is locked, and the analyst has minimal or no opportunity to iterate on model choices after seeing the data.\n\nThis is the opposite of typical exploratory data analysis --- and it is where TMLE shines.\n\nThis chapter demonstrates how to implement TMLE in a clean-room regulatory context, using a motivating example inspired by the **NSAIDs vs. opioids acute kidney injury (AKI)** safety question.\n\n---\n\n# 1. Clinical Motivation\n\n## The Regulatory Question\n\nA distributed research network (similar to the FDA Sentinel system) has flagged a potential safety signal:\n\n> **Does initiation of prescription NSAIDs increase the 90-day risk of acute kidney injury compared to initiation of prescription opioids among adults with musculoskeletal pain?**\n\nThis question arises in a post-marketing surveillance context where:\n\n- **Raw patient-level data cannot leave participating sites** (privacy, legal, or contractual constraints)\n- The analysis must be **pre-specified** in a Statistical Analysis Plan (SAP) before any data access\n- Results must be **reproducible** --- running the same code on the same data yields identical results\n- The analyst cannot iterate on model specifications after seeing the data\n- There is an **audit trail** documenting every analysis step\n\n### Key elements\n\n- **Target population:** Adults aged 18-80 with a new musculoskeletal pain diagnosis initiating either NSAIDs or opioids\n- **Treatment:** NSAID initiation (A = 1) vs. opioid initiation (A = 0)\n- **Outcome:** AKI within 90 days (binary)\n- **Decision:** Should the NSAID label carry a stronger AKI warning? Should prescribing guidelines be updated?\n\n:::{.callout-note}\n## Why TMLE for Clean-Room?\n\nTraditional regression-based analyses require the analyst to choose a single model specification --- a process that invites data-dependent decisions. Every time an analyst looks at the data and adjusts a model, the pre-specification principle is compromised. TMLE with Super Learner sidesteps this problem entirely:\n\n1. **Pre-specify a learner library, not a single model.** The SAP lists the candidate algorithms. Cross-validation --- not the analyst --- picks the best combination. No post-hoc model selection is required.\n2. **Double robustness protects you.** Even if the outcome model or the treatment model is misspecified, the estimate remains consistent as long as at least one is correct. This is invaluable when you cannot iterate after seeing the data.\n3. **Influence-curve inference is automatic.** Valid standard errors come directly from the efficient influence curve --- no bootstrap needed, no distributional assumptions beyond the nonparametric model.\n4. **Full determinism.** Given the same data, learner library, and random seed, the entire pipeline produces bit-identical results. Every run is reproducible.\n5. **The audit trail writes itself.** Cross-validated learner weights, the fluctuation parameter, and every diagnostic are logged as natural byproducts of the algorithm.\n\nIn short, TMLE turns the clean-room constraint from a limitation into a strength: the algorithm makes the decisions that the analyst is not allowed to make.\n:::\n\n---\n\n# 2. Clean-Room Workflow Overview\n\nA clean-room analysis proceeds in distinct phases. Each phase has a clear purpose and strict boundaries. Before we walk through the details, here is the high-level roadmap:\n\n:::{.callout-note}\n## Phase 1: Protocol Development (before data access)\n\nEverything happens on paper before you touch the data. This is the foundation of the entire analysis.\n\n- Define the causal question, DAG, and estimand\n- Write the SAP specifying all analysis steps\n- Pre-specify the Super Learner library\n- Define all diagnostics that will be run\n- Lock the analysis code in a version-controlled repository\n:::\n\n:::{.callout-tip}\n## Phase 2: Data Preparation (minimal data contact)\n\nData preparation follows pre-written scripts. The analyst executes queries but does not explore.\n\n- Execute pre-written data extraction queries\n- Apply inclusion/exclusion criteria\n- Create analysis-ready dataset\n- No exploratory analysis\n:::\n\n:::{.callout-important}\n## Phase 3: Analysis Execution (locked code)\n\nThis is where the pre-specified TMLE pipeline runs. The analyst presses \"go\" and does not modify anything.\n\n- Run the pre-specified TMLE pipeline\n- Generate all pre-specified diagnostics\n- No code modifications allowed\n- Capture all output deterministically\n:::\n\n:::{.callout-warning}\n## Phase 4: Reporting\n\nResults are interpreted according to pre-specified decision rules. Any deviation from the protocol is documented.\n\n- Interpret results according to pre-specified rules\n- Document any deviations from the protocol\n- Maintain audit trail\n:::\n\nWe now walk through each phase.\n\n---\n\n# 3. Phase 1: Pre-Specified Protocol\n\n## 3.1 Causal Question and Estimand\n\nBefore touching any data, we write down exactly what we want to estimate and why.\n\n**Question (plain language):** What is the 90-day AKI risk if all eligible patients initiated NSAIDs, compared to if all eligible patients initiated opioids?\n\n**Estimand:** Average Treatment Effect on the risk difference scale:\n\n$$\n\\psi = E[Y(1)] - E[Y(0)]\n$$\n\nwhere $Y(1)$ is the potential AKI outcome under NSAID initiation and $Y(0)$ under opioid initiation.\n\n## 3.2 Causal Model (DAG)\n\n```\nConfounders (W):\n  age, sex, CKD stage, diabetes, hypertension,\n  prior NSAID use, prior opioid use, ACE/ARB use,\n  number of concomitant medications, healthcare utilization\n\n      W\n     / \\\n    v   v\n    A -> Y\n```\n\nAll measured confounders $W$ affect both treatment choice $A$ and outcome $Y$. The active comparator design (NSAID vs. opioid) helps control for confounding by indication --- both groups have pain requiring treatment.\n\n## 3.3 Assumptions\n\nThe causal identification assumptions must be stated and scrutinized before the analysis begins. These are the claims that no statistical method can verify from data alone.\n\n:::{.callout-warning}\n## Causal Assumptions --- State Them Clearly, Question Them Honestly\n\nEvery causal estimate rests on untestable assumptions. In a clean-room analysis, these are locked into the protocol and cannot be revised after seeing results. Be explicit about where each assumption could fail:\n\n- **Consistency:** Initiation of a new NSAID (or opioid) prescription, irrespective of specific agent within class. This assumes that within-class variation in drug choice does not meaningfully affect AKI risk.\n- **Exchangeability:** Conditional on $W$, treatment choice is independent of potential outcomes. *This is the most fragile assumption.* Unmeasured confounders --- OTC NSAID use, frailty, kidney function trajectory --- could violate it. The E-value sensitivity analysis (Section 8) quantifies how strong such confounding would need to be.\n- **Positivity:** Both drugs are plausible options for all covariate strata. Severe CKD patients are rarely prescribed NSAIDs, which could lead to near-violations. The propensity score overlap diagnostics will flag this.\n:::\n\n## 3.4 Pre-Specified Analysis Plan\n\nThe SAP is the contract between the analyst and the regulator. Once signed, every element below is locked.\n\n:::{.callout-important}\n## Statistical Analysis Plan --- Locked Before Data Access\n\nThe following specifications are frozen in the SAP. No modifications are permitted after data access.\n\n1. **Primary estimator:** TMLE with Super Learner\n2. **Super Learner library:**\n   - `SL.glm` (logistic regression)\n   - `SL.glm.interaction` (logistic with all two-way interactions)\n   - `SL.step` (stepwise regression)\n   - `SL.mean` (intercept-only, for benchmarking)\n3. **Number of cross-validation folds:** 5\n4. **Propensity score bounds:** Truncate at [0.025, 0.975]\n5. **Secondary estimators:** G-computation, IPTW (for comparison)\n6. **Pre-specified diagnostics:** PS overlap, weight distribution, covariate balance (SMD < 0.1 threshold), EIC mean check\n7. **Sensitivity analyses:** E-value for unmeasured confounding\n8. **Seed:** 20260101 (locked in SAP)\n\nWhy does each element matter? The learner library determines what models the algorithm can consider. The CV folds control the bias-variance trade-off in model selection. The PS bounds prevent extreme weights. The diagnostics confirm that the estimation procedure is operating in a regime where we trust it. And the seed ensures anyone can reproduce the exact numerical result.\n:::\n\n---\n\n# 4. Simulated Claims-Like Data\n\nWe simulate data resembling insurance claims with realistic variable distributions and nonlinear relationships. In a real clean-room analysis, this section would be replaced by the pre-written data extraction queries from Phase 2.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ggplot2' was built under R version 4.4.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'stringr' was built under R version 4.4.3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.6.0\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# ============================================================\n# LOCKED SEED — specified in the Statistical Analysis Plan\n# ============================================================\nset.seed(20260101)\n\nn <- 8000\n\n# --- Baseline confounders (claims-derived) ---\n\n# Demographics\nage  <- round(runif(n, 18, 80))\nmale <- rbinom(n, 1, 0.45)\n\n# Comorbidities (from diagnosis codes)\n# CKD stage (0=none, 1=mild, 2=moderate, 3=severe)\nckd <- sample(0:3, n, replace = TRUE,\n              prob = c(0.70, 0.15, 0.10, 0.05))\ndiabetes   <- rbinom(n, 1, plogis(-2.0 + 0.03 * age + 0.5 * (ckd > 0)))\nhypertension <- rbinom(n, 1, plogis(-1.5 + 0.04 * age + 0.3 * male))\n\n# Medication history\nprior_nsaid <- rbinom(n, 1, 0.35)\nprior_opioid <- rbinom(n, 1, 0.20)\nace_arb     <- rbinom(n, 1, plogis(-1.8 + 0.8 * hypertension + 0.5 * diabetes))\n\n# Healthcare utilization (proxy for overall health burden)\nn_rx <- rpois(n, lambda = 3 + 0.05 * age + 2 * (ckd > 1) + diabetes)\nn_visits <- rpois(n, lambda = 2 + 0.02 * age + ckd + diabetes)\n\n# --- Treatment model ---\n# NSAIDs are preferentially prescribed to:\n# - younger patients\n# - those without CKD (contraindication concern)\n# - those with prior NSAID use (familiarity)\n# - those without ACE/ARB use (drug interaction concern)\n# Includes nonlinear age effect and interactions\nlp_trt <- 0.3 +\n  -0.02 * (age - 50) +\n  -0.0005 * (age - 50)^2 +\n  -0.8 * (ckd >= 2) +\n  -0.3 * (ckd == 1) +\n  -0.2 * diabetes +\n  0.5 * prior_nsaid +\n  -0.3 * prior_opioid +\n  -0.4 * ace_arb +\n  -0.01 * n_rx +\n  0.15 * male +\n  0.3 * prior_nsaid * (ckd == 0)  # interaction: prior NSAID use matters more without CKD\n\nA <- rbinom(n, 1, plogis(lp_trt))\n\n# --- Outcome model ---\n# AKI risk depends on treatment and confounders\n# True effect: NSAIDs moderately increase AKI risk\nlp_out <- -4.5 +\n  0.45 * A +                              # true causal effect (harmful)\n  0.03 * (age - 50) +\n  0.0003 * (age - 50)^2 +\n  0.6 * (ckd == 1) +\n  1.2 * (ckd == 2) +\n  2.0 * (ckd >= 3) +\n  0.4 * diabetes +\n  0.3 * hypertension +\n  0.5 * ace_arb +\n  0.05 * n_rx +\n  0.25 * A * (ckd >= 2) +                # interaction: NSAIDs more harmful with CKD\n  0.15 * A * ace_arb +                    # interaction: NSAIDs + ACE/ARB\n  -0.1 * male\n\nY <- rbinom(n, 1, plogis(lp_out))\n\ndat <- tibble(\n  age, male, ckd, diabetes, hypertension,\n  prior_nsaid, prior_opioid, ace_arb,\n  n_rx, n_visits, A, Y\n)\n```\n:::\n\n\n\n\n### True causal effect\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute the true ATE from the data-generating process\np1_true <- plogis(-4.5 + 0.45 * 1 + 0.03 * (age - 50) + 0.0003 * (age - 50)^2 +\n                    0.6 * (ckd == 1) + 1.2 * (ckd == 2) + 2.0 * (ckd >= 3) +\n                    0.4 * diabetes + 0.3 * hypertension + 0.5 * ace_arb +\n                    0.05 * n_rx + 0.25 * 1 * (ckd >= 2) + 0.15 * 1 * ace_arb +\n                    -0.1 * male)\n\np0_true <- plogis(-4.5 + 0.45 * 0 + 0.03 * (age - 50) + 0.0003 * (age - 50)^2 +\n                    0.6 * (ckd == 1) + 1.2 * (ckd == 2) + 2.0 * (ckd >= 3) +\n                    0.4 * diabetes + 0.3 * hypertension + 0.5 * ace_arb +\n                    0.05 * n_rx + 0.25 * 0 * (ckd >= 2) + 0.15 * 0 * ace_arb +\n                    -0.1 * male)\n\ntrue_ate <- mean(p1_true - p0_true)\ncat(\"True ATE (risk difference):\", round(true_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue ATE (risk difference): 0.0334 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"True risk under NSAIDs: \", round(mean(p1_true), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue risk under NSAIDs:  0.0852 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"True risk under opioids:\", round(mean(p0_true), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue risk under opioids: 0.0518 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"AKI event rate overall: \", round(mean(Y), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAKI event rate overall:  0.0664 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Treatment prevalence:   \", round(mean(A), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTreatment prevalence:    0.5044 \n```\n\n\n:::\n:::\n\n\n\n\n### Data summary (what the analyst sees)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Covariate distributions by treatment group\ndat %>%\n  group_by(A) %>%\n  summarise(\n    n          = n(),\n    mean_age   = mean(age),\n    pct_male   = mean(male),\n    pct_ckd_2plus = mean(ckd >= 2),\n    pct_diabetes  = mean(diabetes),\n    pct_htn    = mean(hypertension),\n    pct_prior_nsaid = mean(prior_nsaid),\n    pct_ace_arb = mean(ace_arb),\n    mean_n_rx  = mean(n_rx),\n    aki_rate   = mean(Y),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 11\n      A     n mean_age pct_male pct_ckd_2plus pct_diabetes pct_htn\n  <int> <int>    <dbl>    <dbl>         <dbl>        <dbl>   <dbl>\n1     0  3965     52.5    0.433        0.211         0.452   0.667\n2     1  4035     46.1    0.476        0.0949        0.353   0.589\n# ℹ 4 more variables: pct_prior_nsaid <dbl>, pct_ace_arb <dbl>,\n#   mean_n_rx <dbl>, aki_rate <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n# 5. Phase 3: Locked Analysis Pipeline\n\nThe following code represents the **locked analysis** that runs without modification. Every step is pre-specified. We walk through each step with a plain-language explanation first, then show the code.\n\n## 5.1 Step 1: Propensity Score Estimation\n\nBefore we can estimate the treatment effect, we need to model the treatment assignment mechanism. The propensity score answers the question: given a patient's baseline characteristics, how likely were they to receive NSAIDs rather than opioids?\n\n:::{.callout-tip}\n## Step 1: Estimate the Propensity Score\n\nThe propensity score $g(W) = P(A = 1 \\mid W)$ estimates each patient's probability of receiving NSAIDs given their baseline covariates. We need this for two reasons:\n\n1. It allows us to construct the **clever covariate** that targets the TMLE update toward the causal parameter of interest.\n2. It helps us assess **positivity** --- whether both treatments are plausible for all patients.\n\nThe model formula and truncation bounds were locked in the SAP before data access. Truncation at [0.025, 0.975] prevents extreme inverse-probability weights from individual observations dominating the estimate.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# PRE-SPECIFIED: Propensity score model\n# SAP Section 4.2: Use logistic regression with all baseline\n# covariates, squared age term, and CKD indicators\n# ============================================================\n\ncovariates <- c(\"age\", \"male\", \"ckd\", \"diabetes\", \"hypertension\",\n                \"prior_nsaid\", \"prior_opioid\", \"ace_arb\", \"n_rx\", \"n_visits\")\n\n# Convert CKD to factor for proper modeling\ndat <- dat %>%\n  mutate(ckd_f = factor(ckd))\n\ng_formula <- A ~ age + I(age^2) + male + ckd_f + diabetes + hypertension +\n  prior_nsaid + prior_opioid + ace_arb + n_rx + n_visits +\n  prior_nsaid:ckd_f + ace_arb:diabetes\n\ng_mod <- glm(g_formula, family = binomial, data = dat)\n\ndat$ps <- predict(g_mod, type = \"response\")\n\n# PRE-SPECIFIED: Truncate at [0.025, 0.975]\ndat$ps_trunc <- pmax(0.025, pmin(0.975, dat$ps))\n```\n:::\n\n\n\n\n## 5.2 Step 2: Pre-Specified Diagnostics (Covariate Balance)\n\nThese diagnostics are run **before** looking at the effect estimate, to confirm that the propensity score model is adequate. Think of this as a quality gate: if the diagnostics fail, we know the estimation is unreliable regardless of what number comes out.\n\n### Propensity score overlap\n\nThe overlap plot is the most important single diagnostic. If the two treatment groups have propensity score distributions that do not overlap, we are trying to compare patients who are fundamentally different --- and no statistical method can rescue that.\n\n:::{.callout-note}\n## What to Look For: Propensity Score Overlap\n\nA healthy overlap plot shows two distributions that cover a similar range, with substantial overlap in the middle. Warning signs include:\n\n- **Separation:** If the two curves barely overlap, positivity is violated and the estimate will rely heavily on extrapolation.\n- **Spikes near 0 or 1:** Patients with propensity scores near the boundaries contribute extreme weights. The truncation at [0.025, 0.975] mitigates this, but if many patients are truncated, the effective estimand changes.\n- **Asymmetry:** If one group is concentrated in a narrow range while the other is spread out, consider whether the target population needs to be restricted.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 1: Propensity score overlap\n# SAP Section 5.1\n# ============================================================\n\nggplot(dat, aes(x = ps, fill = factor(A, labels = c(\"Opioid\", \"NSAID\")))) +\n  geom_density(alpha = 0.45) +\n  labs(\n    x = \"Estimated propensity score P(NSAID | W)\",\n    y = \"Density\",\n    fill = \"Treatment\",\n    title = \"Diagnostic 1: Propensity Score Overlap\"\n  ) +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"#4477AA\", \"#EE6677\"))\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quantile summary\ndat %>%\n  group_by(Treatment = factor(A, labels = c(\"Opioid\", \"NSAID\"))) %>%\n  summarise(\n    min  = round(min(ps), 3),\n    p5   = round(quantile(ps, 0.05), 3),\n    p25  = round(quantile(ps, 0.25), 3),\n    median = round(median(ps), 3),\n    p75  = round(quantile(ps, 0.75), 3),\n    p95  = round(quantile(ps, 0.95), 3),\n    max  = round(max(ps), 3),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 8\n  Treatment   min    p5   p25 median   p75   p95   max\n  <fct>     <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl>\n1 Opioid    0.075 0.202 0.328  0.447 0.561 0.733 0.841\n2 NSAID     0.077 0.287 0.459  0.564 0.667 0.801 0.841\n```\n\n\n:::\n:::\n\n\n\n\n### Covariate balance: Standardized Mean Differences\n\n:::{.callout-note}\n## What to Look For: Covariate Balance\n\nStandardized Mean Differences (SMDs) measure how different the treatment groups are on each covariate. The SAP pre-specifies a threshold of SMD < 0.1 for adequate balance.\n\n- **Unadjusted SMDs** show the raw imbalance in the data. Large values confirm confounding is present.\n- **Weighted SMDs** show the imbalance after IPTW adjustment. If all weighted SMDs fall below 0.1, the propensity score model has successfully balanced the groups on observed covariates.\n- **The Love plot** visualizes this comparison. Look for all weighted points (green) to fall left of the dashed 0.1 threshold line.\n\nIf weighted SMDs remain above 0.1 for important confounders, the propensity score model needs refinement --- but in a clean-room analysis, this would have been caught in the simulation phase and the model adjusted before locking the code.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 2: Covariate balance before and after weighting\n# SAP Section 5.2: SMD threshold < 0.1\n# ============================================================\n\ncompute_smd <- function(data, var, trt, weights = NULL) {\n  if (is.null(weights)) weights <- rep(1, nrow(data))\n  d1 <- data[[var]][data[[trt]] == 1]\n  d0 <- data[[var]][data[[trt]] == 0]\n  w1 <- weights[data[[trt]] == 1]\n  w0 <- weights[data[[trt]] == 0]\n  m1 <- weighted.mean(d1, w1)\n  m0 <- weighted.mean(d0, w0)\n  s1 <- sqrt(sum(w1 * (d1 - m1)^2) / sum(w1))\n  s0 <- sqrt(sum(w0 * (d0 - m0)^2) / sum(w0))\n  pooled_sd <- sqrt((s1^2 + s0^2) / 2)\n  if (pooled_sd == 0) return(0)\n  (m1 - m0) / pooled_sd\n}\n\n# Stabilized IPTW weights for balance assessment\np_A <- mean(dat$A)\ndat$sw <- ifelse(dat$A == 1,\n                 p_A / dat$ps_trunc,\n                 (1 - p_A) / (1 - dat$ps_trunc))\n\nbalance_vars <- c(\"age\", \"male\", \"ckd\", \"diabetes\", \"hypertension\",\n                  \"prior_nsaid\", \"prior_opioid\", \"ace_arb\", \"n_rx\", \"n_visits\")\n\nsmd_raw <- sapply(balance_vars, function(v) compute_smd(dat, v, \"A\"))\nsmd_wt  <- sapply(balance_vars, function(v) compute_smd(dat, v, \"A\", dat$sw))\n\nbalance_df <- tibble(\n  Covariate  = balance_vars,\n  Unadjusted = round(abs(smd_raw), 3),\n  Weighted   = round(abs(smd_wt), 3)\n)\n\nbalance_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   Covariate    Unadjusted Weighted\n   <chr>             <dbl>    <dbl>\n 1 age               0.363    0.005\n 2 male              0.086    0.005\n 3 ckd               0.344    0.004\n 4 diabetes          0.204    0.001\n 5 hypertension      0.162    0.003\n 6 prior_nsaid       0.373    0.008\n 7 prior_opioid      0.076    0.009\n 8 ace_arb           0.165    0.005\n 9 n_rx              0.283    0.009\n10 n_visits          0.225    0.005\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Love plot\nbalance_long <- balance_df %>%\n  pivot_longer(-Covariate, names_to = \"Method\", values_to = \"SMD\")\n\nggplot(balance_long, aes(x = SMD, y = reorder(Covariate, SMD),\n                         color = Method, shape = Method)) +\n  geom_point(size = 3) +\n  geom_vline(xintercept = 0.1, linetype = \"dashed\", color = \"grey50\") +\n  labs(\n    x = \"Absolute Standardized Mean Difference\",\n    y = \"\",\n    title = \"Diagnostic 2: Covariate Balance (Love Plot)\",\n    subtitle = \"Dashed line = 0.1 threshold from SAP\"\n  ) +\n  theme_minimal() +\n  scale_color_manual(values = c(\"#EE6677\", \"#228833\"))\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n### Weight distribution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 3: Weight distribution\n# SAP Section 5.3\n# ============================================================\n\nggplot(dat, aes(x = sw, fill = factor(A, labels = c(\"Opioid\", \"NSAID\")))) +\n  geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +\n  labs(\n    x = \"Stabilized IPTW weight\",\n    y = \"Count\",\n    fill = \"Treatment\",\n    title = \"Diagnostic 3: Weight Distribution\"\n  ) +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"#4477AA\", \"#EE6677\")) +\n  geom_vline(xintercept = 1, linetype = \"dashed\", color = \"grey40\")\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncat(\"Weight summary:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWeight summary:\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(dat$sw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.5361  0.7450  0.8946  1.0013  1.1163  6.5225 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Fraction > 5:\", round(mean(dat$sw > 5), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFraction > 5: 4e-04 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Fraction > 10:\", round(mean(dat$sw > 10), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFraction > 10: 0 \n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 5.3 Step 3: Primary Estimator --- TMLE (by hand)\n\nWith diagnostics confirming adequate overlap and balance, we proceed to estimation. TMLE is a multi-step algorithm. We walk through each step with a plain-language explanation, then the code. If you have read the KH Stats TMLE tutorial, you will recognize the same logic here --- just applied in a clean-room regulatory context.\n\n:::{.callout-note}\n## Step 3a: Fit the Initial Outcome Model (Q)\n\nFirst, we build a model to predict the outcome (AKI) from treatment and covariates. This is called the \"initial Q\" --- think of it as our first rough guess at each patient's risk under each treatment scenario.\n\nWe fit one model and then generate three sets of predictions:\n\n- **Q1**: predicted risk if the patient had received NSAIDs (set A = 1 for everyone)\n- **Q0**: predicted risk if the patient had received opioids (set A = 0 for everyone)\n- **QA**: predicted risk under the treatment they actually received\n\nThese predictions are \"initial\" because TMLE will update them in the targeting step to reduce bias for the specific causal parameter we care about.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# PRIMARY ANALYSIS: TMLE\n# SAP Section 6.1\n# ============================================================\n\nlogit <- function(p) log(p / (1 - p))\n\n# --- Step 3a: Initial outcome model ---\n# Pre-specified model form from SAP\nq_formula <- Y ~ A + age + I(age^2) + male + ckd_f + diabetes + hypertension +\n  prior_nsaid + prior_opioid + ace_arb + n_rx + n_visits +\n  A:ckd_f + A:ace_arb + A:diabetes\n\nq_mod <- glm(q_formula, family = binomial, data = dat)\n\n# Initial predictions\nQ1_init <- predict(q_mod, newdata = dat %>% mutate(A = 1), type = \"response\")\nQ0_init <- predict(q_mod, newdata = dat %>% mutate(A = 0), type = \"response\")\nQA_init <- predict(q_mod, type = \"response\")\n\ncat(\"Initial outcome model fitted.\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nInitial outcome model fitted.\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Q1 range:\", round(range(Q1_init), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nQ1 range: 0.0084 0.7659 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Q0 range:\", round(range(Q0_init), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nQ0 range: 0.0045 0.5594 \n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-important}\n## Step 3b: Compute the Clever Covariate\n\nThe clever covariate bridges the outcome model and the treatment model. It tells the fluctuation step *where* to adjust the initial predictions and *by how much*.\n\nFor the ATE, the clever covariate for each observation is:\n\n$$H(A, W) = \\frac{A}{g(W)} - \\frac{1-A}{1-g(W)}$$\n\nFor treated patients (A = 1), this simplifies to $1/g(W)$ --- the inverse of their probability of being treated. For controls (A = 0), it is $-1/(1 - g(W))$. Patients who received an unlikely treatment get a larger clever covariate, meaning the targeting step will adjust their predictions more. This is the mechanism through which TMLE \"borrows strength\" from the propensity score to correct the outcome model.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Step 3b: Clever covariate ---\nH_A <- dat$A / dat$ps_trunc - (1 - dat$A) / (1 - dat$ps_trunc)\nH_1 <- 1 / dat$ps_trunc\nH_0 <- -1 / (1 - dat$ps_trunc)\n\ncat(\"Clever covariate range:\", round(range(H_A), 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClever covariate range: -6.28 12.93 \n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-warning}\n## Step 3c: Fluctuation (Targeting) Step\n\nThis is the step that makes TMLE special. We fit a simple logistic regression with:\n\n- **Outcome:** the observed Y\n- **Offset:** the logit of our initial predictions (QA_init)\n- **Covariate:** the clever covariate H(A, W)\n- **No intercept** (-1 in the formula)\n\nThe single coefficient from this regression, called epsilon, tells us how much and in which direction to shift our initial predictions. The offset locks in the initial predictions; epsilon only adjusts them in the direction that reduces bias for the ATE specifically.\n\nThis is the \"targeting\" in Targeted Maximum Likelihood --- the initial model is updated to be optimal for our specific estimand, not just for prediction in general.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Step 3c: Fluctuation (targeting) model ---\nfluc <- glm(dat$Y ~ -1 + offset(logit(QA_init)) + H_A,\n            family = binomial)\nepsilon <- coef(fluc)\n\ncat(\"Epsilon (fluctuation parameter):\", round(epsilon, 5), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEpsilon (fluctuation parameter): -0.00741 \n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-tip}\n## Step 3d-e: Update Predictions and Compute the Final TMLE Estimate\n\nNow we apply the epsilon update to get our final, targeted predictions:\n\n- Shift Q1_init and Q0_init on the logit scale by epsilon times their respective clever covariates\n- Transform back to the probability scale using the inverse-logit (plogis)\n- Average the updated predictions across all patients to get the counterfactual risks\n- Take the difference to get the ATE\n\nThe resulting estimate, $\\hat{\\psi}_{TMLE}$, is doubly robust: it is consistent if either the outcome model or the propensity score model is correctly specified. It also solves the efficient influence curve estimating equation, which means it achieves the smallest possible variance among regular asymptotically linear estimators.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Step 3d: Updated predictions ---\nQ1_star <- plogis(logit(Q1_init) + epsilon * H_1)\nQ0_star <- plogis(logit(Q0_init) + epsilon * H_0)\n\n# --- Step 3e: TMLE estimate ---\ntmle_risk1 <- mean(Q1_star)\ntmle_risk0 <- mean(Q0_star)\ntmle_ate   <- tmle_risk1 - tmle_risk0\n\ncat(\"TMLE risk (NSAIDs): \", round(tmle_risk1, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTMLE risk (NSAIDs):  0.0912 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"TMLE risk (opioids):\", round(tmle_risk0, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTMLE risk (opioids): 0.0512 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"TMLE ATE:           \", round(tmle_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTMLE ATE:            0.04 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"True ATE:           \", round(true_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue ATE:            0.0334 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Step 3f: Inference via efficient influence curve ---\neic <- (dat$A / dat$ps_trunc) * (dat$Y - Q1_star) + Q1_star - tmle_risk1 -\n       ((1 - dat$A) / (1 - dat$ps_trunc)) * (dat$Y - Q0_star) - Q0_star + tmle_risk0\n\ntmle_se <- sqrt(var(eic) / n)\ntmle_ci <- tmle_ate + c(-1.96, 1.96) * tmle_se\n\ncat(\"\\n=== PRIMARY RESULT ===\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n=== PRIMARY RESULT ===\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"TMLE ATE:\", round(tmle_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTMLE ATE: 0.04 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"SE:      \", round(tmle_se, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSE:       0.0064 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% CI:  [\", round(tmle_ci[1], 4), \",\", round(tmle_ci[2], 4), \"]\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% CI:  [ 0.0275 , 0.0525 ]\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"p-value: \", round(2 * pnorm(-abs(tmle_ate / tmle_se)), 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\np-value:  0 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# --- Step 3g: Verify EIC mean ≈ 0 ---\ncat(\"EIC mean:\", round(mean(eic), 8), \" (should be ~0)\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEIC mean: 0  (should be ~0)\n```\n\n\n:::\n:::\n\n\n\n\n:::{.callout-caution}\n## Why Is the EIC Mean Zero?\n\nThe efficient influence curve (EIC) for the TMLE estimate should have a mean of approximately zero. This is not a coincidence --- it is a direct consequence of the targeting step.\n\nWhen we fit the fluctuation model with the clever covariate, the score equation of that logistic regression forces the EIC estimating equation to be solved. In other words, the targeting step guarantees that the mean of the EIC is (numerically) zero.\n\n**Why this matters for clean-room analysis:** The EIC mean is a built-in diagnostic. If it deviates meaningfully from zero, something went wrong in the implementation --- perhaps a coding error, numerical overflow in the logit transformation, or a problem with the propensity score truncation. In a locked analysis where you cannot inspect intermediate results, having an automatic self-check is invaluable.\n\n**What \"approximately zero\" means in practice:** Machine precision means you will see values like 1e-15 to 1e-8. Values larger than 1e-4 warrant investigation. Values larger than 1e-2 indicate a serious problem.\n:::\n\n---\n\n## 5.4 Step 4: Secondary Estimators (for comparison)\n\nThe SAP pre-specifies secondary estimators so that the primary TMLE result can be compared for consistency. If all three estimators agree, this strengthens confidence in the result. If they disagree, the TMLE estimate is preferred due to its double robustness, but the discrepancy is documented.\n\n### G-computation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# SECONDARY ANALYSIS 1: G-computation\n# SAP Section 6.2\n# ============================================================\n\ngcomp_risk1 <- mean(Q1_init)\ngcomp_risk0 <- mean(Q0_init)\ngcomp_ate   <- gcomp_risk1 - gcomp_risk0\n\ncat(\"G-computation ATE:\", round(gcomp_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nG-computation ATE: 0.0423 \n```\n\n\n:::\n:::\n\n\n\n\n### IPTW\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# SECONDARY ANALYSIS 2: IPTW with stabilized weights\n# SAP Section 6.3\n# ============================================================\n\nrisk1_iptw <- with(dat, sum(sw * Y * (A == 1)) / sum(sw * (A == 1)))\nrisk0_iptw <- with(dat, sum(sw * Y * (A == 0)) / sum(sw * (A == 0)))\niptw_ate   <- risk1_iptw - risk0_iptw\n\ncat(\"IPTW ATE:\", round(iptw_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIPTW ATE: 0.0408 \n```\n\n\n:::\n:::\n\n\n\n\n### Comparison table\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# RESULTS COMPARISON TABLE\n# SAP Section 7\n# ============================================================\n\nresults <- tibble(\n  Estimator = c(\"Unadjusted\", \"G-computation\", \"IPTW\", \"TMLE\"),\n  ATE = round(c(\n    mean(dat$Y[dat$A == 1]) - mean(dat$Y[dat$A == 0]),\n    gcomp_ate,\n    iptw_ate,\n    tmle_ate\n  ), 4),\n  SE = round(c(NA, NA, NA, tmle_se), 4),\n  CI_lower = round(c(NA, NA, NA, tmle_ci[1]), 4),\n  CI_upper = round(c(NA, NA, NA, tmle_ci[2]), 4)\n)\n\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  Estimator        ATE      SE CI_lower CI_upper\n  <chr>          <dbl>   <dbl>    <dbl>    <dbl>\n1 Unadjusted    0.0041 NA       NA       NA     \n2 G-computation 0.0423 NA       NA       NA     \n3 IPTW          0.0408 NA       NA       NA     \n4 TMLE          0.04    0.0064   0.0275   0.0525\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n## 5.5 Step 5: Post-Estimation Diagnostics\n\n### Clever covariate distribution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 4: Clever covariate ranges\n# SAP Section 5.4\n# ============================================================\n\ncc_df <- tibble(\n  H = H_A,\n  Treatment = factor(dat$A, labels = c(\"Opioid\", \"NSAID\"))\n)\n\nggplot(cc_df, aes(x = H, fill = Treatment)) +\n  geom_histogram(bins = 60, alpha = 0.5, position = \"identity\") +\n  labs(\n    x = \"Clever covariate H(A, W)\",\n    y = \"Count\",\n    fill = \"Treatment\",\n    title = \"Diagnostic 4: Clever Covariate Distribution\"\n  ) +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"#4477AA\", \"#EE6677\"))\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n### Influence curve stability\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 5: Influence curve distribution\n# SAP Section 5.5\n# ============================================================\n\nggplot(tibble(eic = eic), aes(x = eic)) +\n  geom_histogram(bins = 60, fill = \"#228833\", alpha = 0.7) +\n  geom_vline(xintercept = 0, linetype = \"dashed\", color = \"red\") +\n  labs(\n    x = \"Efficient influence curve value\",\n    y = \"Count\",\n    title = \"Diagnostic 5: EIC Distribution\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncat(\"EIC summary:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEIC summary:\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(eic)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-8.35531 -0.09618 -0.04799  0.00000  0.07999  4.88995 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\nTop 5 most influential observations:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTop 5 most influential observations:\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(sort(abs(eic), decreasing = TRUE), 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      37     4648     3572      501     5800 \n8.355309 4.889952 4.527676 4.280250 4.274389 \n```\n\n\n:::\n:::\n\n\n\n\n### Predicted risk distribution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# DIAGNOSTIC 6: Predicted outcome distributions\n# SAP Section 5.6\n# ============================================================\n\npred_df <- tibble(\n  Q1_star = Q1_star,\n  Q0_star = Q0_star,\n  diff = Q1_star - Q0_star\n)\n\nggplot(pred_df, aes(x = diff)) +\n  geom_histogram(bins = 50, fill = \"#CC6677\", alpha = 0.7) +\n  geom_vline(xintercept = mean(pred_df$diff), linetype = \"solid\", color = \"black\") +\n  geom_vline(xintercept = true_ate, linetype = \"dashed\", color = \"red\") +\n  labs(\n    x = \"Individual-level risk difference (Q1* - Q0*)\",\n    y = \"Count\",\n    title = \"Diagnostic 6: Distribution of Individual Treatment Effects\",\n    subtitle = \"Black line = TMLE ATE; Red dashed = True ATE\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\n---\n\n# 6. Super Learner Integration\n\nIn the by-hand implementation above, we used parametric logistic regression for both nuisance models. In a real clean-room analysis, the SAP would specify a Super Learner library. This section shows how that integration works conceptually.\n\n:::{.callout-tip}\n## Why Super Learner Eliminates Analyst Discretion\n\nThis is the key insight that makes TMLE and Super Learner a natural fit for the clean-room framework:\n\n1. **No analyst discretion:** The learner library is pre-specified in the SAP. Cross-validation --- not the analyst --- selects the optimal weighted combination. The analyst never chooses \"which model fits better.\"\n2. **Reproducible:** Given the same data, seed, and library, Super Learner always produces the same result. There is no subjectivity in the model selection step.\n3. **Flexible without overfitting:** Multiple candidate models are considered --- including flexible machine learning algorithms --- but the cross-validation oracle inequality ensures the ensemble performs nearly as well as the best single learner. This reduces the risk of misspecification without introducing analyst degrees of freedom.\n4. **Auditable:** The cross-validated risk of each learner and its weight in the ensemble are logged automatically. A reviewer can see exactly which models contributed and how much, providing full transparency into the \"black box.\"\n\nIn a traditional analysis, the analyst might try logistic regression, see poor fit, try adding interactions, check AIC, try a different link function --- each step introducing data-dependent decisions. Super Learner replaces this entire iterative process with a single, pre-specified, cross-validated procedure.\n:::\n\n### Pre-specified Super Learner library (from SAP)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# SAP Section 4.3: Super Learner specification\n# ============================================================\n\nlibrary(SuperLearner)\n\n# Pre-specified learner library (locked in SAP)\nSL_library <- c(\n  \"SL.glm\",               # logistic regression\n  \"SL.glm.interaction\",   # logistic with interactions\n  \"SL.step\",              # stepwise selection\n  \"SL.mean\"               # intercept-only (benchmark)\n)\n\n# NOTE: In a webR environment, compiled learners like SL.ranger\n# or SL.xgboost may not be available. The library above uses\n# only R-native learners.\n\n# Outcome model via Super Learner\nW_matrix <- dat %>% select(age, male, ckd, diabetes, hypertension,\n                            prior_nsaid, prior_opioid, ace_arb,\n                            n_rx, n_visits)\n\nQ_SL <- SuperLearner(\n  Y = dat$Y,\n  X = cbind(A = dat$A, W_matrix),\n  family = binomial(),\n  SL.library = SL_library,\n  cvControl = list(V = 5)\n)\n\n# Treatment model via Super Learner\ng_SL <- SuperLearner(\n  Y = dat$A,\n  X = W_matrix,\n  family = binomial(),\n  SL.library = SL_library,\n  cvControl = list(V = 5)\n)\n\n# Inspect cross-validated learner weights\ncat(\"Outcome model weights:\\n\")\nQ_SL$coef\n\ncat(\"\\nTreatment model weights:\\n\")\ng_SL$coef\n\n# These weights are part of the audit trail — they document which\n# learners contributed most without analyst discretion\n```\n:::\n\n\n\n\n### Using Super Learner predictions in TMLE\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predictions for TMLE\nQ1_SL <- predict(Q_SL, newdata = cbind(A = 1, W_matrix))$pred\nQ0_SL <- predict(Q_SL, newdata = cbind(A = 0, W_matrix))$pred\nQA_SL <- predict(Q_SL, newdata = cbind(A = dat$A, W_matrix))$pred\n\nps_SL <- predict(g_SL, newdata = W_matrix)$pred\nps_SL <- pmax(0.025, pmin(0.975, ps_SL))\n\n# Then proceed with clever covariate, fluctuation, and inference\n# exactly as in the by-hand implementation above\n```\n:::\n\n\n\n\n---\n\n# 7. The Audit Trail\n\n:::{.callout-important}\n## The Audit Trail --- Every Step Is Documented\n\nA clean-room analysis must maintain a complete record of every computational step. The audit trail is not optional --- it is the mechanism by which reviewers, regulators, and future analysts can verify that the pre-specified protocol was followed exactly.\n\nThe structure below captures the key elements: protocol version, software environment, diagnostics summary, and all results. In a real analysis, this would be supplemented by the version-controlled git commit hash of the analysis code, the SHA-256 hash of the input dataset, and a log of all computational warnings.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# AUDIT TRAIL\n# ============================================================\n\naudit <- list(\n  protocol_version = \"v1.0\",\n  sap_version = \"v1.0\",\n  analysis_date = Sys.Date(),\n  r_version = R.version.string,\n  seed = 20260101,\n  sample_size = n,\n\n  # Diagnostics summary\n  diagnostics = list(\n    ps_range = round(range(dat$ps), 4),\n    ps_truncation = c(0.025, 0.975),\n    max_smd_unadjusted = round(max(balance_df$Unadjusted), 3),\n    max_smd_weighted = round(max(balance_df$Weighted), 3),\n    smd_threshold = 0.1,\n    balance_achieved = all(balance_df$Weighted < 0.1),\n    max_weight = round(max(dat$sw), 2),\n    eic_mean = round(mean(eic), 8)\n  ),\n\n  # Primary result\n  primary_result = list(\n    estimator = \"TMLE\",\n    ate = round(tmle_ate, 4),\n    se = round(tmle_se, 4),\n    ci_95 = round(tmle_ci, 4),\n    p_value = round(2 * pnorm(-abs(tmle_ate / tmle_se)), 4)\n  ),\n\n  # Secondary results\n  secondary_results = list(\n    gcomp_ate = round(gcomp_ate, 4),\n    iptw_ate = round(iptw_ate, 4)\n  )\n)\n\n# Print audit summary\ncat(\"=== AUDIT TRAIL ===\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=== AUDIT TRAIL ===\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Protocol:\", audit$protocol_version, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nProtocol: v1.0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Date:\", as.character(audit$analysis_date), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDate: 2026-02-25 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"R:\", audit$r_version, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR: R version 4.4.2 (2024-10-31 ucrt) \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Seed:\", audit$seed, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSeed: 20260101 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"N:\", audit$sample_size, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nN: 8000 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\n--- Diagnostics ---\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n--- Diagnostics ---\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"PS range:\", audit$diagnostics$ps_range, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPS range: 0.0754 0.8414 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Max SMD (weighted):\", audit$diagnostics$max_smd_weighted, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMax SMD (weighted): 0.009 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Balance achieved:\", audit$diagnostics$balance_achieved, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBalance achieved: TRUE \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"EIC mean:\", audit$diagnostics$eic_mean, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEIC mean: 0 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\n--- Primary Result ---\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n--- Primary Result ---\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"ATE:\", audit$primary_result$ate, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nATE: 0.04 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% CI:\", audit$primary_result$ci_95, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% CI: 0.0275 0.0525 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"p-value:\", audit$primary_result$p_value, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\np-value: 0 \n```\n\n\n:::\n:::\n\n\n\n\n---\n\n# 8. Sensitivity Analysis: E-value\n\nThe E-value is our quantitative answer to the question: \"How strong would unmeasured confounding need to be to explain away this result?\" This is always the final step in a causal analysis, because no statistical method --- not even TMLE --- can address unmeasured confounding from data alone.\n\n:::{.callout-warning}\n## Interpreting the E-value\n\nThe E-value quantifies the minimum strength of association that an unmeasured confounder would need to have with **both** the treatment and the outcome (on the risk ratio scale, conditional on measured covariates) to fully explain away the observed causal effect.\n\n**How to read it:**\n\n- An E-value of 1.0 means the result is already null --- no unmeasured confounding is needed to explain it away.\n- Larger E-values indicate greater robustness. An E-value of 3.0 means an unmeasured confounder would need to triple the risk of both treatment and outcome (beyond what measured confounders explain) to nullify the finding.\n- The E-value for the confidence interval bound closest to the null tells you how strong confounding would need to be to make the result statistically non-significant.\n\n**In the NSAID/AKI context:** Consider what unmeasured confounders might exist --- OTC NSAID use (not captured in claims), frailty, kidney function trajectory. Would any of these plausibly have the association strength indicated by the E-value? If the E-value is large relative to known risk factors, the result is more credible.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================================\n# SENSITIVITY ANALYSIS: E-value\n# SAP Section 8.1\n# ============================================================\n\n# Convert risk difference to risk ratio for E-value computation\nrisk_ratio <- tmle_risk1 / tmle_risk0\n\n# E-value formula for risk ratios\ncompute_evalue <- function(rr) {\n  if (rr >= 1) {\n    rr + sqrt(rr * (rr - 1))\n  } else {\n    1/rr + sqrt(1/rr * (1/rr - 1))\n  }\n}\n\nevalue_point <- compute_evalue(risk_ratio)\n\n# E-value for confidence interval bound closest to null\nrr_ci_lower <- (tmle_risk0 + tmle_ci[1]) / tmle_risk0  # approximate\nevalue_ci <- if(rr_ci_lower > 1) compute_evalue(rr_ci_lower) else 1\n\ncat(\"Risk ratio (NSAIDs vs opioids):\", round(risk_ratio, 3), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRisk ratio (NSAIDs vs opioids): 1.782 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"E-value (point estimate):\", round(evalue_point, 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nE-value (point estimate): 2.96 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"E-value (CI bound):\", round(evalue_ci, 2), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nE-value (CI bound): 2.45 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"\\nInterpretation: An unmeasured confounder would need an association\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nInterpretation: An unmeasured confounder would need an association\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"of at least RR =\", round(evalue_point, 2), \"with both treatment and outcome\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nof at least RR = 2.96 with both treatment and outcome\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"(above and beyond measured confounders) to explain away the\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(above and beyond measured confounders) to explain away the\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"observed effect.\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nobserved effect.\n```\n\n\n:::\n:::\n\n\n\n\n---\n\n# 9. Interpretation in Regulatory Context\n\n## Results summary\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"=== REGULATORY SUMMARY ===\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=== REGULATORY SUMMARY ===\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Study: Post-marketing safety analysis of NSAIDs vs opioids for AKI risk\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStudy: Post-marketing safety analysis of NSAIDs vs opioids for AKI risk\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Design: Active comparator, new user, cohort study\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDesign: Active comparator, new user, cohort study\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Method: Pre-specified TMLE with parametric nuisance models\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMethod: Pre-specified TMLE with parametric nuisance models\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Primary endpoint: 90-day acute kidney injury\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPrimary endpoint: 90-day acute kidney injury\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"NSAIDs (n =\", sum(dat$A == 1), \"): estimated 90-day AKI risk =\",\n    round(tmle_risk1 * 100, 2), \"%\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNSAIDs (n = 4035 ): estimated 90-day AKI risk = 9.12 %\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Opioids (n =\", sum(dat$A == 0), \"): estimated 90-day AKI risk =\",\n    round(tmle_risk0 * 100, 2), \"%\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOpioids (n = 3965 ): estimated 90-day AKI risk = 5.12 %\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Risk difference:\", round(tmle_ate * 100, 2), \"percentage points\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRisk difference: 4 percentage points\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"95% CI:\", round(tmle_ci[1] * 100, 2), \"to\", round(tmle_ci[2] * 100, 2),\n    \"percentage points\\n\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n95% CI: 2.75 to 5.25 percentage points\n```\n\n\n:::\n\n```{.r .cell-code}\nif (tmle_ci[1] > 0) {\n  cat(\"Conclusion: Statistically significant increase in AKI risk with NSAIDs.\\n\")\n  cat(\"The results support updating prescribing guidelines to include AKI risk\\n\")\n  cat(\"assessment, particularly for patients with pre-existing CKD.\\n\")\n} else if (tmle_ci[2] < 0) {\n  cat(\"Conclusion: Statistically significant decrease in AKI risk with NSAIDs.\\n\")\n} else {\n  cat(\"Conclusion: The risk difference is not statistically significant.\\n\")\n  cat(\"Continued monitoring is recommended.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nConclusion: Statistically significant increase in AKI risk with NSAIDs.\nThe results support updating prescribing guidelines to include AKI risk\nassessment, particularly for patients with pre-existing CKD.\n```\n\n\n:::\n:::\n\n\n\n\n## How TMLE supports the regulatory decision\n\n| Regulatory concern | How TMLE addresses it |\n|---|---|\n| Pre-specification required | SAP locks the learner library, seed, and analysis code |\n| Must be reproducible | Deterministic given data + seed + code |\n| Model selection bias | Super Learner eliminates manual model selection |\n| Robustness to misspecification | Double robustness protects against either nuisance model being wrong |\n| Valid inference | Influence-curve standard errors do not require bootstrap |\n| Auditable | Cross-validated learner weights, diagnostics, and the fluctuation parameter are all logged |\n| Transparent | Every step (initial model, clever covariate, targeting, inference) has a clear purpose |\n\n## What assumptions are most fragile?\n\n1. **Unmeasured confounding:** OTC NSAID use is not captured in claims data. Frailty and functional status are poorly measured. The E-value provides a benchmark for how strong this confounding would need to be.\n\n2. **Positivity in CKD subgroups:** Patients with severe CKD are rarely prescribed NSAIDs. The propensity score overlap diagnostic should flag this. If violated, consider restricting to the subpopulation with adequate overlap or using stochastic interventions.\n\n3. **Outcome misclassification:** AKI may be under-coded in claims data. This affects interpretation but not the validity of the TMLE procedure.\n\n---\n\n# 10. Distributed Data Extension\n\n:::{.callout-note}\n## Why Meta-Analysis of Site-Level TMLE Estimates Works\n\nIn true multi-site analyses (like the FDA Sentinel system), patient-level data cannot be shared across sites. The clean-room TMLE approach handles this naturally through a two-stage procedure:\n\n**Stage 1: Ship the locked code.** The coordinating center distributes the identical, version-controlled analysis code to each participating site. Each site runs the full TMLE pipeline --- propensity score estimation, diagnostics, targeting, inference --- on its own local data. Because the code is locked and the seed is fixed, the analysis is deterministic at each site.\n\n**Stage 2: Combine via meta-analysis.** Each site returns only summary statistics: the point estimate, standard error, and sample size. The coordinating center combines these using inverse-variance weighted meta-analysis. No patient-level data ever leaves any site.\n\n**Why this works theoretically:** Each site's TMLE estimate is asymptotically normal with an influence-curve-based standard error. Inverse-variance weighting of asymptotically normal estimators is itself asymptotically efficient. The approach is valid as long as the causal assumptions hold within each site and the estimand is the same across sites.\n\n**Practical advantages:**\n\n- Privacy is preserved --- only aggregate statistics are shared\n- Each site can have a different covariate distribution (heterogeneity in confounders)\n- The forest plot reveals cross-site consistency, which strengthens or weakens the overall conclusion\n- If one site shows a qualitatively different result, this flags potential site-specific issues (different coding practices, different patient populations) for investigation\n:::\n\n### Site-level TMLE\n\n1. Ship the locked analysis code to each site\n2. Each site runs the TMLE pipeline on its local data\n3. Sites return summary statistics: point estimate, standard error, sample size\n4. The coordinating center performs meta-analysis across sites\n\n### Meta-analysis of site-level TMLE estimates\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulated multi-site results\nsite_results <- tibble(\n  site = c(\"Site A\", \"Site B\", \"Site C\", \"Site D\"),\n  n = c(3200, 2100, 1800, 900),\n  ate = c(0.018, 0.022, 0.015, 0.025),\n  se = c(0.006, 0.008, 0.009, 0.014)\n)\n\n# Inverse-variance weighted meta-analysis\nsite_results <- site_results %>%\n  mutate(\n    w = 1 / se^2,\n    w_ate = w * ate\n  )\n\nmeta_ate <- sum(site_results$w_ate) / sum(site_results$w)\nmeta_se  <- sqrt(1 / sum(site_results$w))\nmeta_ci  <- meta_ate + c(-1.96, 1.96) * meta_se\n\ncat(\"Meta-analytic TMLE:\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMeta-analytic TMLE:\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"  ATE:\", round(meta_ate, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ATE: 0.019 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"  SE:\", round(meta_se, 4), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  SE: 0.0041 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"  95% CI: [\", round(meta_ci[1], 4), \",\", round(meta_ci[2], 4), \"]\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  95% CI: [ 0.0111 , 0.027 ]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Forest plot of site-level results\nsite_results <- site_results %>%\n  mutate(\n    ci_low = ate - 1.96 * se,\n    ci_high = ate + 1.96 * se\n  )\n\nmeta_row <- tibble(\n  site = \"Meta-analysis\",\n  n = sum(site_results$n),\n  ate = meta_ate,\n  se = meta_se,\n  ci_low = meta_ci[1],\n  ci_high = meta_ci[2]\n)\n\nforest_df <- bind_rows(site_results, meta_row) %>%\n  mutate(site = factor(site, levels = rev(c(site_results$site, \"Meta-analysis\"))))\n\nggplot(forest_df, aes(x = ate, y = site)) +\n  geom_point(aes(size = ifelse(site == \"Meta-analysis\", 4, 2.5)),\n             shape = ifelse(forest_df$site == \"Meta-analysis\", 18, 16)) +\n  geom_errorbarh(aes(xmin = ci_low, xmax = ci_high), height = 0.2) +\n  geom_vline(xintercept = 0, linetype = \"dashed\", color = \"grey50\") +\n  labs(\n    x = \"ATE (Risk Difference)\",\n    y = \"\",\n    title = \"Forest Plot: Site-Level TMLE Estimates\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](03-08-tmle-clean-room_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n\n---\n\n# Key Takeaways\n\n1. **TMLE is naturally suited for clean-room regulatory analysis** because it replaces manual model selection with pre-specified machine learning (Super Learner) and cross-validation.\n\n2. **The entire analysis pipeline can be pre-specified** in a Statistical Analysis Plan: learner library, seed, truncation bounds, diagnostic criteria, and decision rules --- all locked before data access.\n\n3. **Reproducibility is guaranteed** by deterministic seeds, version-controlled code, and the algorithmic nature of TMLE + Super Learner.\n\n4. **The audit trail documents** propensity score overlap, covariate balance, weight distributions, the fluctuation parameter, influence curve behavior, and cross-validated learner weights --- providing full transparency.\n\n5. **Double robustness** protects the estimate even when one nuisance model is misspecified --- a critical property when the analyst cannot iterate on model specifications.\n\n6. **Influence-curve inference** provides valid standard errors without the computational burden of bootstrap, which matters in distributed settings where each site runs the analysis independently.\n\n7. **The clean-room framework extends to distributed data networks** by shipping locked code to each site and combining site-level TMLE estimates via meta-analysis.\n\n8. **Sensitivity analysis (E-value)** should always accompany the primary result to quantify robustness to unmeasured confounding --- the one assumption that no statistical method can address.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.2 (2024-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 26200)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] lubridate_1.9.3 forcats_1.0.0   stringr_1.6.0   dplyr_1.1.4    \n [5] purrr_1.0.2     readr_2.1.5     tidyr_1.3.1     tibble_3.2.1   \n [9] ggplot2_3.5.2   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.6      jsonlite_2.0.0    compiler_4.4.2    tidyselect_1.2.1 \n [5] scales_1.3.0      yaml_2.3.10       fastmap_1.2.0     R6_2.6.1         \n [9] labeling_0.4.3    generics_0.1.3    knitr_1.49        htmlwidgets_1.6.4\n[13] munsell_0.5.1     pillar_1.9.0      tzdb_0.4.0        rlang_1.1.6      \n[17] utf8_1.2.4        stringi_1.8.7     xfun_0.49         timechange_0.3.0 \n[21] cli_3.6.5         withr_3.0.2       magrittr_2.0.3    digest_0.6.37    \n[25] grid_4.4.2        rstudioapi_0.17.1 hms_1.1.3         lifecycle_1.0.4  \n[29] vctrs_0.6.5       evaluate_1.0.5    glue_1.8.0        farver_2.1.2     \n[33] fansi_1.0.6       colorspace_2.1-1  rmarkdown_2.29    tools_4.4.2      \n[37] pkgconfig_2.0.3   htmltools_0.5.8.1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "03-08-tmle-clean-room_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}