---
title: "Chapter 3.5: Advanced Diagnostics and Sensitivity Analyses"
format: html
---

# Chapter 3.5  
## Advanced Diagnostics and Sensitivity Analyses  
*Ensuring credible causal conclusions in real-world longitudinal data*

::: {.callout-note}
## Learning objectives
- Assess positivity and overlap using propensity score diagnostics
- Evaluate nuisance model performance (outcome model and treatment model)
- Perform weight diagnostics for IPTW and TMLE, including truncation sensitivity
- Compute and interpret E-values for sensitivity to unmeasured confounding
- Use negative control outcomes and exposures to detect residual bias
- Apply TMLE-specific diagnostics: influence curve summaries and calibration checks
:::

::: {.callout-important}
## Sources and scope
This chapter is educational. Causal conclusions depend on identification assumptions (e.g., consistency, exchangeability, positivity) and on diagnostic evidence that the data support the target estimand. When flexible machine learning is used for nuisance estimation, valid inference typically requires cross-fitting or a cross-validated TMLE variant, plus appropriate rate conditions.
:::

```{r}
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4,
  fig.align = "center",
  message = FALSE,
  warning = FALSE
)
```

:::{.callout-important}
## Why Diagnostics Are Non-Negotiable

Causal inference is never just about estimating an effect — it is about **credibly defending** that effect. As an epidemiologist, you know that an estimate without diagnostics is like a clinical trial without a protocol: technically possible, but not credible. Diagnostics and sensitivity analyses are essential components of the causal roadmap because:

- Identifying assumptions are never fully testable
- Real-world data contain missingness, selection, unmeasured confounding, and misclassification
- Positivity and model misspecification can quietly undermine estimation
- Regulatory-grade RWE requires transparency and robustness checks

This chapter walks through:

1. Diagnostics for identification assumptions
2. Positivity and overlap assessment
3. Diagnostics for nuisance models (Q and g)
4. Weight diagnostics
5. Sensitivity analyses for unmeasured confounding
6. Negative controls
7. TMLE-specific diagnostics
8. Longitudinal diagnostics (LMTP / longitudinal TMLE)
:::

---

:::{.callout-note}
## Diagnostics for Identification Assumptions

The core identification assumptions are:

- **Consistency**: the observed outcome under the treatment actually received equals the potential outcome under that treatment
- **Exchangeability (No unmeasured confounding)**: conditional on measured covariates, treatment groups are comparable
- **Positivity**: every covariate stratum has a non-zero probability of each treatment level
- **Correct nuisance model specification**: the models for treatment and outcome are well-specified enough to avoid bias

While not directly testable, their **empirical implications** can be evaluated. Think of these as the load-bearing walls of your analysis -- if any one fails, the whole structure is compromised.
:::

### 1.1 Data structure and quality checks

Before causal modeling:

- Verify time ordering
- Confirm treatment and outcome timestamps
- Inspect missingness patterns
- Look for coding shifts (ICD-9 to ICD-10)
- Examine distributions and implausible values  

:::{.callout-tip}
## DAG Review: Your Causal Roadmap on Paper

A DAG (Directed Acyclic Graph) is not just a statistical formality -- it is your most powerful communication tool. When you sit down with clinical collaborators, a DAG makes implicit assumptions explicit. It clarifies:

- **Adjustment sets**: which variables must be conditioned on to block confounding paths
- **Potential unmeasured confounding**: where you lack data on important causes
- **Variables that should *not* be adjusted for**: mediators (which would block the causal path you want to estimate) and colliders (which would open bias paths)

Draw the DAG before writing any code. Share it with your clinical team. If they disagree with an arrow, that disagreement is a scientific conversation worth having before you run a single model.
:::

---

:::{.callout-warning}
## Positivity Diagnostics: When Your Data Cannot Support Your Question

Positivity requires:

> Every combination of covariates has a non-zero probability of receiving each treatment.

**Why this matters so much**: Positivity violations are dangerous because they are silent. Your code will still run, your model will still produce a number, but that number may be driven by a handful of observations with extreme weights rather than by the actual data. In epidemiologic terms, you are extrapolating beyond the support of your data -- making claims about what would happen to people for whom you have essentially no evidence.

Violations cause unstable weights and unreliable estimates.
:::

### 2.1 Propensity score overlap

```r
ps <- predict(glm(A ~ W1 + W2, family = binomial), type = "response")

library(ggplot2)
ggplot(tibble(ps = ps, A = A), aes(x = ps, fill = factor(A))) +
  geom_density(alpha = 0.4)
```

Indicators of concern:

- Mass near 0 or 1
- Disjoint distributions  

:::{.callout-caution}
## Clever Covariate Range (TMLE)

The clever covariate (H) is the quantity TMLE uses to update its initial outcome model. When propensity scores are near 0 or 1, the clever covariate explodes in magnitude -- and a single observation can hijack your entire estimate. Always inspect its range before trusting your TMLE output.

```r
H <- A/ps - (1-A)/(1-ps)
summary(H)
```

Extreme values imply near-positivity violations. If you see values in the hundreds or thousands, your estimate is likely unstable and you should investigate the propensity score distribution.
:::

:::{.callout-tip}
## Remedies for Positivity Violations

When you detect positivity problems, do not simply ignore them. You have several practical options:

- **Restrict to the overlap population**: limit your analysis to the covariate region where both treatment groups have adequate representation. This changes your target population, but the estimate you get is actually supported by data.
- **Truncate weights**: cap extreme weights at a percentile (e.g., 1st and 99th). This introduces a small amount of bias but can dramatically reduce variance.
- **Use stochastic interventions instead of static ones**: rather than asking “what if everyone were treated?”, ask “what if the probability of treatment shifted by some amount?” This naturally respects the data support.
- **Simplify the intervention**: coarser treatment definitions may have better overlap.
:::

---

:::{.callout-note}
## Diagnostics for Nuisance Functions (Q and g)

In causal inference, "nuisance functions" are the models you fit not because you care about their parameters, but because you need them to estimate the causal effect. **Q** is the outcome model (predicting Y given treatment and covariates) and **g** is the treatment model (predicting treatment probability given covariates, i.e., the propensity score). Accurate nuisance models are crucial for TMLE, AIPW, and LMTP. If these models are badly misspecified, your causal estimate inherits that bias -- even with doubly robust methods, you need at least one of Q or g to be well-specified.
:::

### 3.1 Predictive accuracy

- AUC for binary outcomes  
- MSE/R² for continuous  
- Cross-validated risk from SuperLearner  

### 3.2 Calibration plots

```r
dat %>% 
  mutate(pred = Qhat) %>% 
  ggplot(aes(x = pred, y = Y)) +
    geom_point(alpha = 0.3) +
    geom_smooth()
```

### 3.3 Overfitting assessment

Compare:

- Training loss  
- Cross-validated loss  

Large discrepancy → overfitting.

### 3.4 Variable-importance sanity check

Ensure top predictors are *clinically plausible*.

---

:::{.callout-warning}
## Weight Diagnostics: Are a Few Observations Driving Your Results?

Inverse probability weights are used in IPTW, MSMs, and censoring models. Extreme weights are a red flag that a small number of unusual observations are exerting outsized influence on your effect estimate. Always inspect weights before reporting results.

### 4.1 Weight summaries

```r
summary(weights)
quantile(weights, probs = c(0.01, 0.99))
```

Red flags:

- Mean far from 1 (for stabilized weights, the mean should be approximately 1)
- Very heavy tail
- Huge max weights (a single weight of 500 means that one person "counts" as 500 in your pseudo-population)

### 4.2 Visual check

```r
ggplot(tibble(w = weights), aes(x = w)) +
  geom_histogram()
```

### 4.3 Truncation

```r
lower <- quantile(weights, 0.01)
upper <- quantile(weights, 0.99)
w_trunc <- pmin(pmax(weights, lower), upper)
```

Report results both with and without truncation. If they differ substantially, your findings are fragile.
:::

---

## 5. Sensitivity Analyses for Unmeasured Confounding

:::{.callout-note}
## E-values: How Strong Would Unmeasured Confounding Need to Be?

An **E-value** answers a simple but powerful question: *What is the minimum strength of association that an unmeasured confounder would need to have with both the treatment and the outcome -- above and beyond the measured covariates -- to fully explain away the observed effect?*

In plain language: if you find an E-value of 3.5, it means an unmeasured confounder would need to be associated with at least a 3.5-fold increase in both the likelihood of treatment *and* the likelihood of the outcome to reduce your observed effect to the null. The larger the E-value, the more robust your finding is to unmeasured confounding. A small E-value (close to 1) means even weak unmeasured confounding could account for your result.

E-values do not prove the absence of confounding -- they quantify how extreme an unmeasured confounder would need to be. This helps reviewers and decision-makers calibrate their confidence in the finding.
:::

### 5.2 Quantitative Bias Analysis (QBA)

Simulates impact of:

- Unmeasured confounder prevalence  
- Unmeasured confounder associations  

R packages: **episensr**, **causalsens**


### 5.4 Sensitivity using stochastic interventions

LMTP can quantify robustness of static intervention effects.

---

:::{.callout-important}
## Negative Controls: One of the Most Powerful Tools for Detecting Unmeasured Confounding

Negative controls are arguably the single most informative diagnostic you can run for unmeasured confounding. The logic is elegant: pick an outcome that you *know* the treatment should not affect, but that shares the same confounding structure as your primary outcome. Then estimate the "effect" of treatment on that negative control outcome. If you find an association, something is wrong -- and that something is almost certainly unmeasured confounding or some other systematic bias.

**Negative control outcomes (NCOs):**

- Causally unrelated to treatment
- Share confounding structures with the real outcome

If TMLE of treatment on the NCO produces a non-null result, confounding likely remains in your primary analysis.

Example:

```r
tmle_nco <- tmle(
  Y = dat$negative_event,
  A = dat$treatment,
  W = dat[, confounders]
)
```

**Negative control exposures** work similarly: pick an exposure that should not affect your outcome but shares the same confounding structure as the real treatment. Both types serve as empirical "smoke tests" for bias.
:::

---

:::{.callout-caution}
## TMLE-Specific Diagnostics: Things That Can Go Wrong in the Targeting Step

TMLE adds a "targeting step" that updates the initial outcome model to optimize bias-variance tradeoff for your specific causal parameter. This step is powerful but can go wrong in subtle ways. Watch for these issues:

### 7.1 Clever covariate behavior

Extreme clever covariate values lead to unstable targeting. If the clever covariate has values in the hundreds or thousands, the fluctuation parameter (epsilon) is being estimated from near-singular data. Revisit your propensity score model.

### 7.2 Targeting step convergence

Check for warnings in logistic fluctuation:

```
glm.fit: algorithm did not converge
```

This warning means the targeting step failed to find a stable update. Common causes include near-positivity violations or a very poor initial fit.

### 7.3 Influence-curve distribution

```r
IC <- tmle_fit$ic
mean(IC); var(IC)
```

The mean of the influence curve should be approximately zero (this is the efficient influence function equation that TMLE solves). Heavy tails in the IC distribution suggest that Wald-type confidence intervals may have poor coverage -- consider bootstrap-based inference instead.
:::

---

:::{.callout-warning}
## Longitudinal Diagnostics: Where Problems Compound Over Time

In longitudinal settings (LMTP, longitudinal TMLE), every challenge from the cross-sectional case is amplified. Positivity must hold at *every* timepoint. Weights are *multiplied* across time, so moderate violations at each step can produce extreme cumulative weights. This section is critical for anyone working with repeated-measures or time-varying treatment data.

### 8.1 Sequential positivity

Check treatment probabilities at each timepoint. A treatment probability of 0.05 at one time may be acceptable, but if you have 10 timepoints with similar probabilities, the cumulative probability can become vanishingly small.

### 8.2 Cumulative weights

```r
cumw <- apply(weight_matrix, 1, prod)
hist(cumw)
```

Extreme cumulative weights signal instability. Even if weights look reasonable at each individual time step, their product can be enormous.

### 8.3 Truncation across time

Truncate weights at each time step or truncate cumulative weights. Both approaches involve tradeoffs -- per-step truncation is more conservative but can compound across time; cumulative truncation directly addresses the problem but is harder to interpret.

### 8.4 Time-varying confounding sanity checks

Ensure intermediate variables are not inappropriate colliders. In longitudinal settings, a variable can be both a confounder (of future treatment-outcome relationships) and a mediator (of past treatment effects). The DAG becomes essential for sorting out what should and should not be conditioned on at each time step.
:::

---

:::{.callout-tip}
## Recommended Diagnostics Workflow: A Practical Checklist

Use this as a step-by-step checklist for every causal analysis. Print it out, tape it to your monitor, or include it in your analysis plan. Skipping steps here is how "surprising" results end up in print.

### Before estimation

- [ ] Confirm time-ordering of treatment, covariates, and outcome
- [ ] Draw a DAG and review it with clinical collaborators
- [ ] Check missingness patterns (MCAR/MAR/MNAR)
- [ ] Summarize covariate distributions by treatment group (Table 1)

### During estimation

- [ ] Check propensity score overlap (density plots by treatment group)
- [ ] Evaluate weight distributions (summaries, histograms, max values)
- [ ] Inspect Q and g predictions (calibration, AUC, cross-validated risk)
- [ ] Check TMLE targeting step convergence and clever covariate range

### After estimation

- [ ] Run sensitivity analyses (E-values, quantitative bias analysis)
- [ ] Run negative control analyses (NCOs and/or NCEs)
- [ ] Compare across estimators (IPTW, TMLE, AIPW) -- agreement increases credibility
- [ ] Perform robustness checks (population restriction, alternative confounder sets, different SuperLearner libraries)
:::

---

:::{.callout-important}
## Summary: Diagnostics Are the Backbone of Credible Causal Inference

To produce defensible causal evidence, diagnostics must be:

- **Systematic**: follow the workflow above for every analysis, not just when results look surprising
- **Transparent**: report diagnostics in your paper or supplement, not just in your internal notes
- **Documented in the analysis plan**: pre-specify which diagnostics you will run and how you will respond to problems
- **Interpreted with domain expertise**: a propensity score distribution or E-value only becomes meaningful when contextualized by clinical knowledge

With these tools, analysts can judge the **credibility**, **robustness**, and **transportability** of causal findings -- essential for regulatory, clinical, and scientific decision-making. An estimate without diagnostics is not a causal estimate; it is a hope.
:::

```{r}
sessionInfo()
```

---

## Sources and further reading

- VanderWeele TJ, Ding P (2017). Sensitivity analysis in observational research: introducing the E-value. *Ann Intern Med* 167(4):268-274.
- Lipsitch M, Tchetgen Tchetgen E, Cohen T (2010). Negative controls: a tool for detecting confounding and bias in observational studies. *Epidemiology* 21(3):383-388.
- Petersen ML, Porter KE, Gruber S, et al. (2012). Diagnosing and responding to violations in the positivity assumption. *Stat Methods Med Res* 21(1):31-54.
- Gruber S, van der Laan MJ (2010). An application of collaborative targeted maximum likelihood estimation in causal inference and genomics. *Int J Biostat* 6(1):Article 18.
- van der Laan MJ, Rose S (2011). *Targeted Learning*. Springer. Chapter 10 (Diagnostics).
- Hernan MA, Robins JM (2020). *Causal Inference: What If*. Chapters 11-12. [Free online](https://www.hsph.harvard.edu/miguel-hernan/causal-inference-book/)
- `EValue` R package: [CRAN](https://cran.r-project.org/package=EValue)
- `drtmle` R package: [CRAN](https://cran.r-project.org/package=drtmle)

---

## Software Implementation (R)

This example demonstrates key **diagnostic checks** for a TMLE analysis: positivity assessment, clever covariate summaries, weight truncation sensitivity, and E-value computation.

- Simulate a dataset with a near-positivity violation in one confounder stratum
- Run TMLE, then inspect propensity score overlap and clever covariate distribution
- Show truncation sensitivity: compare ATE estimates across different truncation levels
- Compute an E-value for robustness to unmeasured confounding

```{r}
#| eval: false
set.seed(1)
n <- 800
W1 <- rnorm(n)
W2 <- rbinom(n, 1, 0.3)
## Near-positivity violation: W2 = 1 strongly predicts A = 1
A  <- rbinom(n, 1, plogis(-0.5 + 0.4 * W1 + 2.5 * W2))
Y  <- 0.5 * A + 0.8 * W1 - 0.3 * W2 + rnorm(n, sd = 0.5)

W  <- data.frame(W1 = W1, W2 = W2)

## ── 1. Propensity score overlap ──
ps_mod <- glm(A ~ W1 + W2, family = binomial)
ps <- predict(ps_mod, type = "response")
cat("Propensity score summary:\n")
print(summary(ps))
cat("\nMin ps:", round(min(ps), 4),
    "  Max ps:", round(max(ps), 4), "\n")

## ── 2. TMLE with diagnostics ──
if (requireNamespace("tmle", quietly = TRUE)) {
  library(tmle)
  fit <- tmle(Y = Y, A = A, W = W,
              Q.SL.library = "SL.glm", g.SL.library = "SL.glm")

  ## Clever covariate summary
  H1 <- A / ps
  H0 <- (1 - A) / (1 - ps)
  cat("\nClever covariate (treated) — max:", round(max(H1), 1),
      " 99th pctile:", round(quantile(H1, 0.99), 1), "\n")

  ## Influence curve check
  cat("EIC mean:", round(mean(fit$estimates$ATE$IC), 6),
      " (should ≈ 0)\n")

  ## ── 3. Truncation sensitivity ──
  cat("\n── Truncation sensitivity ──\n")
  for (g_bound in c(0.01, 0.025, 0.05, 0.10)) {
    fit_trunc <- tmle(Y = Y, A = A, W = W,
                      Q.SL.library = "SL.glm",
                      g.SL.library = "SL.glm",
                      gbound = g_bound)
    cat(sprintf("  g-bound = %.3f → ATE = %.3f  (SE = %.3f)\n",
                g_bound,
                fit_trunc$estimates$ATE$psi,
                sqrt(fit_trunc$estimates$ATE$var.psi)))
  }
} else {
  message("Install the 'tmle' package:  install.packages('tmle')")
}

## ── 4. E-value (no package needed) ──
## For a risk ratio of 1.5, the E-value formula is:
##   E = RR + sqrt(RR * (RR - 1))
RR <- 1.5
E_val <- RR + sqrt(RR * (RR - 1))
cat("\n── E-value ──\n")
cat("Point estimate RR:", RR, "\n")
cat("E-value:", round(E_val, 2),
    "\n(An unmeasured confounder would need RR ≥",
    round(E_val, 2), "with both A and Y to explain away the effect)\n")
```
